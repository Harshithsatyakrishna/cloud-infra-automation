Day 1:
- Linux VM setup done
- GitHub repo created
- Azure VM accessible via SSH
---------------------------------------------------------------------------------------------------------------------------
Day 2: 
-Practised Linux commands basics 
- Revised few Cloud Topics 
Q. What is SSH? 
    - Secure Shell helps to connect with you remote desktop 
    - Command Line where you can talk to your OS 
    - Transfer Data securly 
Q. What is NSG? 
    - Network Security Group is a firewall between user and the VM 
    - It has inbound and outbound rules to decide the traffic in and out securly 
Q. Why port 22 is needed? 
    - Port 22 is required because SSH uses TCP port 22 by default to remotely access Linux systems. 
    - If the inbound rule for port 22 is blocked in the NSG, the SSH connection cannot reach the VM.
----------------------------------------------------------------------------------------------------------------------------
Day 3:
- Linux + Networking 
  SSH into your Azure Linux VM
    connect from local bash script to the VM 
     bash:- ssh <username>@<public ip>
  Linux Navigation & Files
    * creating check delete files 
         bash:- pwd (Print Working Directory)
                ls(list files & folders in current Directory)
                ls -l(detailed View)
                cd /(Moves you to the root directory)
    * Create Files & Folders
         bash:- mkdir(creates folder)
                cd(Moves into Folder)
                touch(creates file)
                echo "<text> "<filename>(writes text into the file)
                cat <filename>(displays the text in the file)
    * Delete 
         bash:- rm <filename>(deletes only file)
                rm -r<folder>(deletes entire folder)
                
  File Viewing & System Info
    *   bash:-  cat /etc/os-release(Shows linux details,name & version)
                uname -a(shows kernal & system info)
                whoami(Shows which user you are logged in as)
                head /etc/passwd(shows first 10 lines of the file)
                tail /etc/passwd(shows last 10 lines of the file)
  Permissions
    *    - --> normal file 
         d --> directory
         -> -rw-rw-r
             |  |  |
             |  |  ---> others
             |  -------> Group
             ----------->Owner
         In numeric mode, a three-digit value represents specific file permissions (for example, 744.) These are called octal values. 
         The first digit is for owner permissions, the second digit is for group permissions, and the third is for other users. 
         Each permission has a numeric value assigned to it:
        r (read): 4
        w (write): 2
        x (execute): 1
        In the permission value 744, the first digit corresponds to the user, the second digit to the group, and the third digit to others. 
        By adding up the value of each user classification, you can find the file permissions.

        For example, a file might have read, write, and execute permissions for its owner, and only read permission for all other users. That looks like this:

        Owner: rwx = 4+2+1 = 7
        Group: r-- = 4+0+0 = 4
        Others: r-- = 4+0+0 = 4
        The results produce the three-digit value 744.
        You can modify file and directory permissions with the chmod command, which stands for "change mode."
  
  Process & Resource Commands
    * ps -ef(shows all running processes)
      top (live view of system usage)
      df -h (disk usage )
      free -m (memory usage)
      uptime (shows how long server has been running)
  Networking Commands
    * ip a (shows network interfaces & ip addresses(private also))
      ip route(shows routing table)
      ss - tuln(listing ports)
      ping.google.com(test internet connectivity)[* ctrl + C to stop]
      curl.ifconfig.me(shows public ip address)

- Java Concepts 
  Class & Objects ,Constructors
  Data types & Math
  Basic coding 
------------------------------------------------------------------------------------------------------------------------------------
DAY 4:
– Git & GitHub()
  Practised Git Commands though GitBash 
  updated the To DO list through bash not github directly 
    GIT Commands -
       1. git --version [to check the present version]
       2. git update-git-for-windows [to update to latest version]
       3. Configure git - changes made from which account
            git config --global user.name "NAME"
            git config --global user.email "email"
            git config --list [to check the global list ]
       4. Clone & Status 
            git clone <repo-link> [to clone a repo to local machine]
            git status [displays status of the code]
       5. Add,Commit,Push
            git add <filename> [Add untracked file or unstaged changes]
            git add. [when u have many files]
            git commit -m "message" [makes a commit]
            git push origin main [pushes the code to github]
        6. Create new repo
            git init [new repo]
            git remote add origin<link> [links a local Git repository to a remote repository so code can be pushed and pulled.]
            git remote -v [to verify remote]
        7. Branch Commands
            git branch [to check branch]
            git branch -M main [to rename branch]
            git checkout <branch name> [to navigate]
            git checkout -b <new branch name> [to create new branch]
            git branch -d<branch name> [to delete branch]
        8. Merging code
            way-1
                git diff<branch name> [to compare commits ,branches,files etc]
                git merge<branch name> [merge branches]
            way-2
                From VS code choose pull request 
        9. Undoing changes
            Case-1:- Staged changes 
                    git reset <filename>
            Case-2:- Commited changes
                    git reset Head~1 [Reset 1 step back]
            Case-3:- Commited changes with many commits
                    git reset<commit hash>
        Fork- A fork is a new repository that shares code and visibility with the original repository.
                Used to propose changes to someone else's project or to use someone else's project as a starting point for your own idea.
  
  Practised linux commands
  Concepts of Core java + OOPS 
 ------------------------------------------------------------------------------------------------------------------------------
 Day -5 :
  - Started with basic OOPS concepts + coding 

  - Installed Terraform 
  - revised introductional concepts 
  - set up in vs code or first terraform code
  - Created and fetched ,App registrtion for client ID, Tenent ID, Secret ID 
    and assigned new RBAC as contibutor as Terraform does not use your user identity.and got subscription ID 
  - Terraform init 
  - Terraform plan 
  - Basics on terraform 
------------------------------------------------------------------------------------------------------------------------------
Day 6:
  - Terraform Basic of Components 
  - Advantages of Terraform 
  - “I created Azure resources using Terraform”
  - “I understand Terraform state basics”

-------------------------------------------------------------------------------------------------------------------------------
Day -7 
  - Created variables.tf file  to make the code reusable  to avoid hard coding 
        File	                   Purpose
        main.tf	              WHAT to create
      variables.tf	        WHAT inputs are needed
      terraform.tfvars	       ACTUAL values

  - Terraform Remote Backend
      securly store the state file in remote location like Azure blob storage
      Stores centrally so everyone can access the same state file
      helps with state locking to avoid conflicts

 - Terraform Modules 
       if terraform = code 
       modules = clean architecture 
       Modules help us reuse infrastructure code, reduce duplication, and maintain consistency across environments.
       We use a root module with environment-specific variables and reusable child modules for resources like VNet, VM, and Resource Groups.
----------------------------------------------------------------------------------------------------------------------------------
Day -8 
- Installed Docker on windows 
- Docker basic commands practised
- Created Dockerfile for java application
- Built Docker image for java app
- Ran the java app in Docker container
-------------------------------------------------------------------------------------------------------------------
Day -9
- Learned Docker concepts 
-  Docker VS VM 
  Docker is a containerization tool that packages an application along with its dependencies into containers. These containers are lightweight, fast, and share the host operating system’s kernel, which makes them efficient in terms of resource usage.
  On the other hand, a Virtual Machine runs a complete operating system on top of a hypervisor. Each VM requires its own OS, CPU allocation, RAM, and storage, which increases overhead and puts more load on the host machine.
  Because Docker containers share the host OS, they start faster, consume fewer resources, and are easier to scale compared to virtual machines.
  “Docker containers share the host OS and are lightweight, while virtual machines run a full OS and consume more resources.”

- Docker images & Containers
  Docker Image: A Docker image is a lightweight, standalone, and executable package that includes everything needed to run a piece of software, including the code, runtime, libraries, environment variables, and configuration files. Images are read-only templates used to create Docker containers.
  Docker Container: A Docker container is a runtime instance of a Docker image. It is a lightweight, isolated environment where applications can run. Containers share the host system's kernel but have their own filesystem, network interfaces, and process space.
  In summary, a Docker image is the blueprint or template for creating containers, while a Docker container is the actual running instance of that image.

- Dockerfile Commands
  FROM: Specifies the base image to use for the Docker image. It sets the starting point for building the image.
  COPY: Copies files or directories from the host machine into the Docker image at a specified location.
  RUN: Executes commands in a new layer on top of the current image and commits the results to create a new image layer.
  CMD: Provides the default command to run when a container is started from the image. It can be overridden at runtime.
  EXPOSE: Informs Docker that the container listens on the specified network ports at runtime.        

- Docker Baisic Commands
  docker build -t <image-name> .  [Builds a Docker image from a Dockerfile in the current directory]
  docker images  [Lists all Docker images on the local machine]
  docker run -d -p <host-port>:<container-port> <image-name>  [Runs a Docker container in detached mode, mapping host port to container port]
  docker ps  [Lists all running Docker containers]
  docker stop <container-id>  [Stops a running Docker container]
  docker rm <container-id>  [Removes a stopped Docker container]
  docker rmi <image-id>  [Removes a Docker image from the local machine]    
-------------------------------------------------------------------------------------------------------------------
Day -10 
Deploy Java Application using Docker on Azure VM
 - Created a simple Java page 
    basic java server health page 
    Run locally to test the java application

 - Created a Dockerfile to containerize the Java application.
      FROM openjdk:17-jdk-slim
      WORKDIR /app
      COPY . .
      RUN javac HealthServer.java
      CMD ["java", "HealthServer"]
      EXPOSE 8080       

 - Built the Docker image using the Dockerfile.

      docker build -t health-app .
      docker run -p 8080:8080 java-health-app
    - Tested locally "http://localhost:8080/health" to ensure the Java application is working inside the Docker container.

 - SSH into Azure VM and installed Docker on the VM.
       Installed sudo apt update
          sudo apt install -y docker.io
          sudo systemctl start docker
          sudo systemctl enable docker
          sudo usermod -aG docker azureuser
          logout

      3. Now change the NSG to allow inbound traffic on port 8080
          destination port ="8080" [terraform]
      4. Test FROM VM 
          http://<VM_PUBLIC_IP>:8080/health

        

 - Pulled the Docker container from local machine to azure VM. 
     1   [local bash]
          scp -r app azureuser@<VM_PUBLIC_IP>:/home/azureuser
         [ON VM]
          cd app
          docker build -t health-app .
          docker run -d -p 8080:8080 --name health-app health-app

    2.  Now change the NSG to allow inbound traffic on port 8080
          destination port ="8080" [terraform]

 - Run the Docker container on the Azure VM to deploy the Java application.

      docker run -d -p 8080:8080 --name health-app health-app


 - Verified that the Java application is running successfully inside the Docker container on the Azure VM.
    verify:
      docker ps
      curl http://<VM_PUBLIC_IP>:8080/health
-------------------------------------------------------------------------------------------------------------------
Day -11




